#### 堆栈内存管理
- Linux环境下的内存管理
在linux环境下运行的程序，在编译时链接的起始地址都是相同的，而且是一个虚拟地址。linux操作系统需要CPU内存管理单元的支持才能运行，Linux内核通过页表和MMU硬件来管理内存，完成虚拟地址到物理地址的转换、内存读写权限管理等功能。可执行文件在运行时，加载器将可执行文件中的不同section加载到内存中读写权限不同的区域，如代码段、数据段、.bss段、.rodata段等。
在linux环境下，虽然所有的程序编译时使用相同的链接地址，但在程序运行时，相同的虚拟地址会通过MMU转换，映射到不同的物理内存区域，各个可执行文件被加载到内存不同的物理页上，每个进程都有各自的页表，用来记录各自进程中虚拟地址到物理地址的映射关系。通过这种地址管理机制，没个进程都可以独享一份独立的、私有的3GB用户空间。
- 堆栈内存在Linux进程空间的地址分布
堆内存一般在BSS段后面，用户malloc的内存越来越多，堆空间不断往高地址增长。栈空间则紧挨着内核空间，ARM使用的是满递减堆栈，栈指针会从用户空间的高地址往低地址不断增长。在堆与栈中间有一块区域叫做MMAP区域，动态共享库就保存在这片空间上。
#### 栈的管理
- 栈
一种数据结构，先进后出FILO，入栈，出栈
类别：根据栈顶元素，分为满栈（指向栈顶元素）和空栈（指向栈顶元素上方的可用空间）；根据栈的生长方向不同，栈又分为递增栈（栈指针从低地址往高地址增长）和递减栈（栈指针从高地址往低地址增长）。
- 栈的初始化
-栈的初始化就是栈指针SP的初始化。ARM处理器使用R13（SP）和R11寄存器（FP）来管理堆栈
	
		ulimit -s    //查看栈大小（kb）
		//设置栈空间大小为4MB
		ulimit -s 4096
Linux默认给每个用户进程栈分配8MB大小的空间。为防止栈溢出，可参考的原则
1，尽量不在函数内使用大数组，如果确实需要大块内存，可以使用malloc申请动态内存
2，函数的嵌套层数不宜过深
3，递归的层数不宜太深
- 函数调用
一个函数中定义的局部变量、传递的实参都是保存在占中的。没个函数都会有自己专门的栈空间来保存这些数据，每个函数的栈空间都被称为栈帧，每个栈帧都会有两个寄存器FP和SP来维护，FP指向栈帧的底部，SP指向栈帧的顶部。
函数的栈帧除了保存局部变量和实参，还用来保存函数的上下文。main函数中调用了f函数，main函数的栈帧基址FP，main函数的返回地址LR，都需要存在f函数的栈帧中。当f函数运行结束退出时就可以根据栈中保存的地址返回函数的上一级继续执行。
一个程序中往往存在多级函数调用，每一级调用都会运行不同的函数，没个函数都有自己的栈帧空间，没个栈帧都由栈底和栈顶，无论函数调用运行到哪一级，SP总是指向当前正在运行函数栈帧的栈顶，而FP总是指向当前运行函数的栈di

- 参数传递
参数传递过程中，各个参数出栈、压栈的顺序需要有一个约定，这个约定的方式称为调用惯例。

		#include <stdio.h>
		
		int f(int args1, int args2, int args3, int args4, int args5, int args6)
		{
		    int s = 0;
		    s = args1+ args2 + args3 + args4+ args5 + args6;
		    return s;
		
		
		}
		
		int main(void)
		{
		    int sum = 0;
		    sum = f(1,2,3,4,5,6);
		    printf("sum: %d\n", sum);
		    return 0;
		}

常用的调用惯例：
| 调用惯例      |    栈清理方 | 参数入栈  |
| :-------- | --------:| :--: |
| cdecl  | 调用者 |  从右至左   |
| pascal     |   函数本身 |  从左至右  |
| stdcall      |    函数本身 | 从右至左  |
| fastcall      |    函数本身 | 前两个参数使用寄存器，剩下的从右至左  |
| thiscall      |    未定 | 从右至左  |

C语言默认使用cdecl调用惯例
反汇编命令:
``` objectivec
# arm-linux-gnueabi-gcc param.c -o a.out
# arm-linux-gnueabi-objdump -D a.out > a.s
```
- 形参与实参
为什么形参值的改变不会影响实参？
形参只是在函数被调用时才会在栈中分配临时的存储单元，用来保存传递过来的实参值。变量作为实参传递时，只是将变量值复制给了形参，形参和实参在栈中位于不同的存储单元。

- 栈与作用域
全局变量定义在函数体外，其作用域范围为从声明处到文件结束。其他文件如果想使用这个全局变量，则在自己的文件内使用extern声明后即可使用。全局变量的生命周期在整个程序运行期间都是有效的。
1，全局变量的作用域由文件来限定
2，可使用extern进行扩展，被其他文件引用
3，也可以使用static进行限制，只能在本文件中被引用
局部变量，在函数内，函数调用结束，变量即刻被释放。
1，局部变量的作用域由{}限定
2，可以使用static修饰局部变量来改变他们的存储属性（声明周期），但不能改变其作用域。

编译器编译程序时，是根据一堆大括号{}来限定一个变量的作用域的。

- 栈溢出攻击原理
linux进程的栈空间时有固定大小的，一般时8MB。
由于C语言对边界检查的宽松性，即使程序对超出数组的内存单元进行数据篡改，编译器一般也不会报错。
GCC编译器为了防止数组越界访问，一般会在用户定义的数组末尾放入一个保护变量，并根据此变量是否被修改来判断数组是否越界访问。若发现该变量被覆盖，就给当前进程发送一个SIGABRT的信号，终止当前进程的运行。


#### 堆内存管理

- 堆的定义
是linux进程中一片可动态扩展或缩减的内存区域，一般位于BSS段后面
- 堆内存的申请
malloc:申请一块用户指定大小的内存，申请成功后，会返回用户一个指向这块内存的指针，用户可通过该指针对这块内存进行读写
calloc:申请nmemb个单位长度为size的连续空间，并将这块内存空间初始化为0
realloc:动态调整内存块的大小
``` objectivec

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main(void)
{

    char *p = NULL;

    p = (char*)malloc(100);
    printf("%p\n", p);

    memset(p, 0, 100);

    memcpy(p, "hello", 5);

    printf("%s\n", p);

    p = (char *)realloc(p, 200);
    printf("%p\n", p);
    printf("%s\n", p);

    free(p);
    return 0;
}
```

无论使用malloc、calloc、还是realloc函数申请内存空间，申请的内存使用结束后，都要通过free函数进行释放，将这块内存还给系统，否则就会造成内存泄露。

- 堆内存与栈内存的区别
1，堆内存是匿名的，不能像变量那样使用名字直接访问，一般通过指针间接访问。
2，在函数运行期间，对函数栈帧内的内存访问，不能像变量那样通过变量明直接访问，一般通过栈指针FP或SP相对寻址访问。
3，堆内存由程序员自己申请和释放，函数退出时，如果程序员没有主动释放，会造成内存泄露。
4，栈内存由编译器维护，函数运行时开辟一个栈帧空间，函数运行结束，栈帧空间随之销毁释放。